---
description: 针对一些我个人觉得比较经典的题目，给出我的想法和答案，欢迎交流分享。另外英文版的leetcode每一题的discussi区都会有非常优秀的解答。
---

# 1

## [1. Two Sum](https://leetcode.com/problems/two-sum/)[\(1\)](https://leetcode.com/problems/two-sum/) 

给出一个数组，和一个目标数字target，在数组中找出两个数，使两数之和为target，返回两个数的下标。（假设有且仅有一解）

要找到两个和为target，即对于数组中任意一个数num，要判断target-num是否存在于数组中。

```cpp
class Solution
{
  public:
    vector<int> twoSum(vector<int> &nums, int target)
    {

        unordered_map<int, int> map;
        //使用unordered_map在查找target-num的时候时间复杂度为O(1)
        vector<int> ret;
        for (int i = 0; i < nums.size(); i++)
        {
            if (map.find(target - nums[i]) != map.end())
            //对于num[i]，如果能找到map中能找到target - nums[i]，即满足条件
            {
                ret.push_back(i);
                ret.push_back(map[target - nums[i]]);
                return ret;
            }
            map[nums[i]] = i;
        }
        return ret;
    }
};
```

相关问题：167 653 15 18

## [ 2. Longest Palindromic Substring](https://leetcode.com/problems/longest-palindromic-substring/)[\(5\)](https://leetcode.com/problems/longest-palindromic-substring/)

最长回文子串。反向求解，对于字符串中的一个字符，可以将其往左右两边扩展，如果两边的字符相同，就能扩展成一个更长的回文子串。扩展时，要考虑子串长度为奇或偶的两种情况。

```cpp
class Solution
{
  public:
    string longestPalindrome(string s)
    {
        int maxlen = 0;
        int start, end;
        string ret = s;
        for (int i = 0; i < s.length(); i++)
        {
            int len = max(expendPalindrome(s, i, i),
             expendPalindrome(s, i, i + 1));
            //分奇数长度和偶数长度两种情况分开别拓展，取值
            if (len > maxlen)
            {
                maxlen = len;
                start = i - (len - 1) / 2;
                ret = s.substr(start, maxlen);
                //比较得到最长的子串，并计算其起始和终止下标，返回string
            }
        }

        return ret;
    }

    int expendPalindrome(string s, int start, int end)
    {
        //左端和右端没到边界且相等，则可以获得一个更长的回文子串
        while (start >= 0 && end < s.length() && s[start] == s[end])
        {
            start--;
            end++;
        }
        return end - start - 1;
    }
};
```

## [3.Container With Most Water](https://leetcode.com/problems/container-with-most-water/)[\(11\)](https://leetcode.com/problems/container-with-most-water/)

给一串高度，选两个组成容器，求容器最大的容积

设两个指针，start和end，分别表示左右两个边界。那么start从0开始，end从height.size\(\)-1开始，能够让容器的长度最大。然后比较height\[start\]和height\[end\]。

如果height\[0\]&lt;height\[n-1\]，那么对于所有以0为左边边界的容器容量，都不会超过以0和n-1为边界的值。因为其长度一直在变化，而高度始终保持0~height\[0\]，不会超过height\[0\]。所以不需要再进行计算，可直接跳过。所以哪一边的边界高度较小，就可以将其往中心移动。

 max\(  \(end-start\)\*min\(height\[end\]-height\[start\]\)\)

```cpp
class Solution
{
  public:
    int maxArea(vector<int> &height)
    {

        int ret = 0;
        int start = 0, end = height.size() - 1;

        while (start <= end)
        {
            int val = (end - start) * min(height[start], height[end]);
            ret = max(val, ret);
            if (height[start] < height[end])
                start++;
            else
                end--;
        }

        return ret;
    }
};
```

##  [4. Valid Sudoku\(36\)](https://leetcode.com/problems/valid-sudoku/)

判断数独是否有解。

```cpp
class Solution
{
  public:
    bool isValidSudoku(vector<vector<char>> &board)
    {

        vector<vector<int>> used1(9, vector<int>(9, 0));
        vector<vector<int>> used2(9, vector<int>(9, 0));
        vector<vector<int>> used3(9, vector<int>(9, 0));
        //used1表示每一行，used2表示列，used3表示九块九宫格
        for (int i = 0; i < 9; i++)
        {
            for (int j = 0; j < 9; j++)
            {
                if (board[i][j] != '.')
                {
                    int num = board[i][j] - '1';
                    int pos = i / 3 * 3 + j / 3;
                    //通过i,j来确定属于那一块九宫格
                    if (used1[i][num] || 
                        used2[j][num] || used3[pos][num])
                        return false;
                    //如果冲突就返回false，否则将标记置为1，表示已经出现过
                    used1[i][num] = used2[j][num] = used3[pos][num] = 1;
                }
            }
        }

        return true;
    }
};
```

相关问题: 37\(解数独\)

## [ 5. Permutations\(46\)](https://leetcode.com/problems/permutations/)

给一个集合，求所有元素的全排列。

这一系列问题有很多，都是用递归解决的。基本框架：修改-&gt;递归调用进行修改-&gt;撤销修改。

```cpp
class Solution
{
  public:
    vector<vector<int>> ret;

    void helper(vector<int> &temp, vector<int> &nums)
    {
        if (temp.size() == nums.size())
        {
            ret.push_back(temp);
            return;
        }

        for (int i = 0; i < nums.size(); i++)
        {
            if (find(temp.begin(), temp.end(), nums[i]) != temp.end())
                continue;
            //保证数组内的数值不同
            temp.push_back(nums[i]);            
            helper(temp, nums);
            temp.pop_back();
        }
        return;
    }

    vector<vector<int>> permute(vector<int> &nums)
    {
        vector<int> temp;
        helper(temp, nums);
        return ret;
    }
};
```

相关问题：31 39 47 

##  . Maximum Subarray\(53\)

给一个数组，求最大子串（连续的）和。

贪心算法。用sum来记录当前的连续子串的和，只要sum&gt;0，其对最终的结果都是有增益的，而当sum&lt;0时，便可以将其舍弃，从0开始重新求和。在求和过程中记录maxsum，比较max和cur的大小，以及cur和0的大小。

```cpp
class Solution
{
  public:
    int maxSubArray(vector<int> &nums)
    {

        int maxsum = INT_MIN;
        int cursum = 0;
        for (int i = 0; i < nums.size(); i++)
        {
            cursum += nums[i];
            maxsum = cursum > maxsum ? cursum : maxsum;
            cursum = cursum >= 0 ? cursum : 0;
        }
        return maxsum;
    }
};
```



##  . Sort Colors\(75\)

“荷兰国旗"问题。将三种颜色重新排序，使得相同的颜色放在一起。

使用类似快速排序的思想，将三种颜色\(0,1,2\)重新排序，使其有序。定义三个指针，small指向0，large指向2，index指向1。比较index和large的大小，当index&lt;=large时，比较index指针所指向的数的值，如果是0，那么应该将其放在开头，所以将其与small指针指向的数交换数值，并向前移。如果是2，那么就与large指针交换，但index不需要++,因为交换过来的有可能是0，需要继续交换。

```cpp
class Solution
{
  public:
    void sortColors(vector<int> &nums)
    {

        int small = 0, large = nums.size() - 1, index = 0;
        if (nums.size() == 0)
            return;

        while (index <= large)
        {

            if (nums[index] == 0)
            {
                nums[index] = nums[small];
                nums[small] = 0;
                small++;
                index++;
            }
            else if(nums[index]==1)
                index++;
            else if (nums[index] == 2)
            {
                nums[index] = nums[large];
                nums[large] = 2;
                large--;
            }
            
        }
    }
};
```

##  169. Majority Element

一个数组中，存在一个出现次数大于一半的数，求出这个数。

因为这个数必定存在，所以可以记录当前数出现的次数，如果下一个数与之不同，则count--，相同则count++，当count==0时，说明之前的数都不一定是最多的数，重新赋值。

如果这个数不一定存在，则不能使用该算法。

参考:**Boyer-Moore Voting Algorithm**

```cpp
class Solution
{
  public:
    int majorityElement(vector<int> &nums)
    {
        int count = 0;
        int val;
        for (auto num : nums)
        {
            val = count == 0 ? num : val;
            num == val ? count++ : count--;
        }
        return val;
    }
};
```

##  179. Largest Number

给一串数字，求这些数字能组成的最大的数。

最简单的做法就是排序，两两排序后，局部最优能得到全局最优。

在c++中，stl的sort函数第三个参数有多种写法。比较简单的就是lamda表达式。

```cpp
class Solution
{
  public:
    string largestNumber(vector<int> &nums)
    {

        auto comp = [](int a, int b) 
        { return to_string(a) + to_string(b) 
        > to_string(b) + to_string(a); };

        std::sort(nums.begin(), nums.end(), comp);
        if (nums[0] == 0)
            return "0";
        string ret = "";
        for (int i = 0; i < nums.size(); i++)
        {
            ret += to_string(nums[i]);
        }

        return ret;
    }
};
```





