# 1

## [1. Two Sum](https://leetcode.com/problems/two-sum/)[\(1\)](https://leetcode.com/problems/two-sum/) 

给出一个数组，和一个目标数字target，在数组中找出两个数，使两数之和为target，返回两个数的下标。（假设有且仅有一解）

要找到两个和为target，即对于数组中任意一个数num，要判断target-num是否存在于数组中。

```cpp
class Solution
{
  public:
    vector<int> twoSum(vector<int> &nums, int target)
    {

        unordered_map<int, int> map;
        //使用unordered_map在查找target-num的时候时间复杂度为O(1)
        vector<int> ret;
        for (int i = 0; i < nums.size(); i++)
        {
            if (map.find(target - nums[i]) != map.end())
            //对于num[i]，如果能找到map中能找到target - nums[i]，即满足条件
            {
                ret.push_back(i);
                ret.push_back(map[target - nums[i]]);
                return ret;
            }
            map[nums[i]] = i;
        }
        return ret;
    }
};
```

相关问题：167 653 15 18

## [ 2. Longest Palindromic Substring](https://leetcode.com/problems/longest-palindromic-substring/)[\(5\)](https://leetcode.com/problems/longest-palindromic-substring/)

最长回文子串。反向求解，对于字符串中的一个字符，可以将其往左右两边扩展，如果两边的字符相同，就能扩展成一个更长的回文子串。扩展时，要考虑子串长度为奇或偶的两种情况。

```cpp
class Solution
{
  public:
    string longestPalindrome(string s)
    {
        int maxlen = 0;
        int start, end;
        string ret = s;
        for (int i = 0; i < s.length(); i++)
        {
            int len = max(expendPalindrome(s, i, i),
             expendPalindrome(s, i, i + 1));
            //分奇数长度和偶数长度两种情况分开别拓展，取值
            if (len > maxlen)
            {
                maxlen = len;
                start = i - (len - 1) / 2;
                ret = s.substr(start, maxlen);
                //比较得到最长的子串，并计算其起始和终止下标，返回string
            }
        }

        return ret;
    }

    int expendPalindrome(string s, int start, int end)
    {
        //左端和右端没到边界且相等，则可以获得一个更长的回文子串
        while (start >= 0 && end < s.length() && s[start] == s[end])
        {
            start--;
            end++;
        }
        return end - start - 1;
    }
};
```

## [3.Container With Most Water](https://leetcode.com/problems/container-with-most-water/)[\(11\)](https://leetcode.com/problems/container-with-most-water/)

给一串高度，选两个组成容器，求容器最大的容积

设两个指针，start和end，分别表示左右两个边界。那么start从0开始，end从height.size\(\)-1开始，能够让容器的长度最大。然后比较height\[start\]和height\[end\]。

如果height\[0\]&lt;height\[n-1\]，那么对于所有以0为左边边界的容器容量，都不会超过以0和n-1为边界的值。因为其长度一直在变化，而高度始终保持0~height\[0\]，不会超过height\[0\]。所以不需要再进行计算，可直接跳过。所以哪一边的边界高度较小，就可以将其往中心移动。

 max\(  \(end-start\)\*min\(height\[end\]-height\[start\]\)\)

```cpp
class Solution
{
  public:
    int maxArea(vector<int> &height)
    {

        int ret = 0;
        int start = 0, end = height.size() - 1;

        while (start <= end)
        {
            int val = (end - start) * min(height[start], height[end]);
            ret = max(val, ret);
            if (height[start] < height[end])
                start++;
            else
                end--;
        }

        return ret;
    }
};
```

##  [4. Valid Sudoku\(36\)](https://leetcode.com/problems/valid-sudoku/)

判断数独是否有解。

```cpp
class Solution
{
  public:
    bool isValidSudoku(vector<vector<char>> &board)
    {

        vector<vector<int>> used1(9, vector<int>(9, 0));
        vector<vector<int>> used2(9, vector<int>(9, 0));
        vector<vector<int>> used3(9, vector<int>(9, 0));
        //used1表示每一行，used2表示列，used3表示九块九宫格
        for (int i = 0; i < 9; i++)
        {
            for (int j = 0; j < 9; j++)
            {
                if (board[i][j] != '.')
                {
                    int num = board[i][j] - '1';
                    int pos = i / 3 * 3 + j / 3;
                    //通过i,j来确定属于那一块九宫格
                    if (used1[i][num] || 
                        used2[j][num] || used3[pos][num])
                        return false;
                    //如果冲突就返回false，否则将标记置为1，表示已经出现过
                    used1[i][num] = used2[j][num] = used3[pos][num] = 1;
                }
            }
        }

        return true;
    }
};
```

相关问题: 37\(解数独\)

## [ 5. Permutations\(46\)](https://leetcode.com/problems/permutations/)

给一个集合，求所有元素的全排列。

这一系列问题有很多，都是用递归解决的。基本框架：修改-&gt;递归调用进行修改-&gt;撤销修改。

```cpp
class Solution
{
  public:
    vector<vector<int>> ret;

    void helper(vector<int> &temp, vector<int> &nums)
    {
        if (temp.size() == nums.size())
        {
            ret.push_back(temp);
            return;
        }

        for (int i = 0; i < nums.size(); i++)
        {
            if (find(temp.begin(), temp.end(), nums[i]) != temp.end())
                continue;
            //保证数组内的数值不同
            temp.push_back(nums[i]);            
            helper(temp, nums);
            temp.pop_back();
        }
        return;
    }

    vector<vector<int>> permute(vector<int> &nums)
    {
        vector<int> temp;
        helper(temp, nums);
        return ret;
    }
};
```

相关问题：31 47

