# String

## 28. Implement strStr\(\)

实现 strstr\(\)函数

当needle字符串为空的时候，返回0。

基本解法：brute force 滑动窗口。

```cpp
class Solution {
public:
	int strStr( string haystack, string needle )
	{
		if ( needle.length() == 0 )
			return(0);

		for ( int i = 0; haystack[i]; i++ )
		{
			for ( int j = 0;; j++ )
			{
				if ( needle[j] == 0 )
					return(i);
				if ( haystack[i + j] == 0 )
					return(-1);
				if ( haystack[i + j] != needle[j] )
					break;
			}
		}

		return -1;
	}
};
```

此外还有KMP算法、BM算法、Sunday算法用于解决该问题。

##  205. Isomorphic Strings

Given two strings **s** and **t**, determine if they are isomorphic.

Two strings are isomorphic if the characters in **s** can be replaced to get **t**.

All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character but a character may map to itself.

**Example 1:**

```text
Input: s = "egg", t = "add"
Output: true
```

**Example 2:**

```text
Input: s = "foo", t = "bar"
Output: false
```

**Example 3:**

```text
Input: s = "paper", t = "title"
Output: true
```

判断一个字符串s能否通过对字符进行一一映射变换得到字符串t。

记录每个字符对应的映射值，初值为0。如果双方的映射都是0，那么说明这两个字符还没有建立过映射关系。否则，就要检查是否满足两条映射关系，如果不满足，说明不满足一一映射条件。

```cpp
class Solution
{
  public:
	bool isIsomorphic(string s, string t)
	{
		if (s.length() != t.length())
			return false;

		vector<int> pa(128, 0);
		vector<int> pb(128, 0);
		for (int i = 0; s[i]; i++)
		{
			if (pa[s[i]] == 0 && pb[t[i]] == 0)
			{
				pa[s[i]] = t[i];
				pb[t[i]] = s[i];
			}
			else if (pa[s[i]] != t[i] || pb[t[i]] != s[i])
				return false;
		}
		return true;
	}
};
```

##  242. Valid Anagram

判断两个字符串是否同构。统计每个字符的个数即可。

```cpp
class Solution {
public:
	bool isAnagram( string s, string t )
	{
		if ( s.length() != t.length() )
			return(false);
		vector<int>	c1( 26, 0 );
		vector<int>	c2( 26, 0 );
		for ( auto ch : s )
			c1[ch - 'a']++;
		for ( auto ch : t )
			c2[ch - 'a']++;
		for ( int i = 0; i < c1.size(); i++ )
			if ( c1[i] != c2[i] )
				return(false);

		return(true);
	}
};
```

## 257. Binary Tree Paths

求二叉树所有从根结点到叶子结点的路径。

DFS递归即可。

```cpp
class Solution {
public:
	vector<string> ret;
	vector<string> binaryTreePaths( TreeNode* root )
	{
		string temp;
		if ( root == NULL )
			return(ret);
		helper( root, temp );
		return(ret);
	}


	void helper( TreeNode* root, string temp )
	{
		temp += to_string( root->val );
		if ( root->left == NULL && root->right == NULL )
		{
			ret.push_back( temp );
			return;
		}
		temp += "->";
		if ( root->left )
			helper( root->left, temp );
		if ( root->right )
			helper( root->right, temp );
	}
};
```

##  383. Ransom Note

Given an arbitrary ransom note string and another string containing letters from all the magazines, write a function that will return true if the ransom note can be constructed from the magazines ; otherwise, it will return false.

Each letter in the magazine string can only be used once in your ransom note.

判断Ransom字符串能不能由magazines里面的字符组成。还是统计字符个数。

```cpp
class Solution
{
public:
	bool canConstruct(string ransomNote, string magazine)
	{

		vector<int> count(26, 0);
		for (auto ch : magazine)
			count[ch - 'a']++;
		for (auto ch : ransomNote)
		{
			if (count[ch - 'a']-- <= 0)
				return false;
		}

		return true;
	}
};
```

##  387. First Unique Character in a String

字符串中第一个只出现一次的字符。先循环统计个数，再循环找到index

```cpp
class Solution
{
  public:
	int firstUniqChar(string s)
	{
		vector<int> count(26, 0);
		for (auto ch : s)
			count[ch - 'a']++;
		for (int i = 0; s[i]; i++)
			if (count[s[i] - 'a'] == 1)
				return i;
		return -1;
	}
};
```

##  389. Find the Difference

Given two strings **s** and **t** which consist of only lowercase letters.

String **t** is generated by random shuffling string **s** and then add one more letter at a random position.

Find the letter that was added in **t**.  
t是在s变换的基础上加了一个字符，那对于s+t来说，只有一个字符出现奇数次，其他所有字符都出现了偶数次，可以用异或运算找到这个单独的字符。

```cpp
class Solution
{
  public:
	char findTheDifference(string s, string t)
	{

		char ret = 0;
		for (auto ch : s)
			ret ^= ch;
		for (auto ch : t)
			ret ^= ch;
		return ret;
	}
};
```

